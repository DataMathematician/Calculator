# Cтековый калькулятор с использованием ООП.
<br>1. Калькулятор выполнен на основе обратной польской нотации (ОПН).
<br>2. Поддерживает следующие операции: `+, -, *, /, ^, %, ), (, sin, cos, ~ (унарный минус), ! (унарный плюс)` 
<br>3. Поддерживает следующие команды: 
  * `'='`     выдает ответ.
  * `'clear'` удаляет посдеднее отправленное выражение в строку ввода (удаляет последнее значение из стека).
  * `'C'`     удаляет из стека выражений все выражения введенные ранее (очищает стек)
  * `'Q'`     закрывает приложение
  * `'MR'`    чтение значения из памяти
  * `'MC'`    чистит память
  * `'M-'`    вычитает из памяти
  * `'M+'`    добавляет в память
<br> calc.py - исполняемый файл
## Принцип работы
<br>1. Вводится выражение типа: 
  * `6+45*3-(4/2^2)` полностью.
  * `6` `+` `45` `*` `3` `-` `(4/2^2)` по частям. 
  
<br>2. Выражение проверяется на правильность.
<br> Попытка учесть все невозможные для ввода виды выражений. В случае обнаружения невозможности вычисления строки,
будет выведено сообщение о невозможности вычисления выражения.

<br>3. Выражение переводится в обратную польскую нотацию (ОПН).
  * `cos(1)-sin(20)^2` => `1 cos 20 sin 2 ^ -`
  * `6+45*3-(4/2^2)` => `6 45 3 * + 4 2 2 ^ / -`
  * `-sin(cos(70-20)/sin(-20)+2)^3` => `70 20 - cos 20 ~ sin / 2 + sin 3 ^ ~`
  
<br>4. Алгоритм перевода в ОПН.
  * Пока есть ещё символы для чтения.
    * Читаем очередной символ.
    * Если символ цифра или буква, то читается следующий символ и складывается с предыдущим, пока не будут достигнуты символы `( )` или операции (разделение на `123` и `abc`).
    * Если символ является открывающей скобкой, помещаем его в стек операций.
    * Если символ является закрывающей скобкой:
      * До тех пор, пока верхним элементом стека не станет открывающая скобка, выталкиваем элементы из стека в выходную строку.
      * При этом открывающая скобка удаляется из стека, но в выходную строку не добавляется.
    * Если любой другой символ (оператор):
      * Если стек операций пустой:
        * Если символ `-` или `+`  ,то меняем его на `~` или `!` и кладем в стек.
        * Или просто кладем символ в стек.
      * Если стек операций не пустой:
        * Если предыдущий символ `(` и очередной символ `-` или `+`,то меняем его на `~` или `!` и кладем в стек.
        * Если приоритет очередного оператора меньше предыдущего в стеке, то выталкиваем все элементы из стека операций в выходную строку,
        пока верхний элемент стека не будет меньшего или того же приоритета, что и очередной оператор. Кладем в стек.
        * Если приоритет очередного оператора больше предыдущего в стеке, то добавляем в стек.
  * Когда все символы входной строки перебраны, выталкиваем все символы из стека в выходную строку.
  
  <br> Приведенные выше правила исполняются посредством определенных состояний на конкретном шаге (см.`RPN.py`; `class State`):
  * `s_open` - состояние начала строки, для него определены частные случаи (т.е. следующим символом может быть...) такие как:
    * `h_open` - открывающая скобка
    * `h_num` - число
    * `h_uno_op` - унарная операция
    * `h_tgm` - триганометрическая ф-ия
  * `s_close` - состояние конца выражения/подвыражения (необязательно строки), для него определены частные случаи такие как:
    * `h_close` - закрывающая скобка
    * `h_open`
    * `h_spec` - тринарная операция
  * `s_tgm` - состояние триганометрической ф-ии, у него одно частное состояние:
    * `h_open`

<br>5. Вычисляется ОПН согласно следующему алгоритму:
  * Берется очередной токен.
    * Если токен число, то кладется в стек.
    * Если токен выражение, то узнается, операция - унарная/бинарная/...:
      * Унарная - из стека берется последнее значение `stack.pop`, вычисляется согласно операции и результат кладется в конец стека.
      * Бинарная - из стека берутся два посдедних значения `stack.pop`, вычисляются согласно операциии результат кладется в конец стека.
      * По аналогии для остальных...
  * Результат передается на выход.
